<app-demo
  [datasource]="datasource"
  [context]="demoContext"
  [sources]="sources"
>
  <div actions style="display: flex">
    <button (click)="doAppend()">Append</button> /
    <button (click)="doPrepend()">Prepend</button>
    <input [ngModel]="inputValue" (change)="onInputChanged($event.target)" size="2">
  </div>

  <div description>
    <p>
      Adding items at the end and at the beginning of the <em>uiScroll</em> items buffer is possible with
      <em>Adapter.append(foo)</em> and <em>Adapter.prepend(foo)</em> methods respectively.
      The argument of both methods (foo) could be an item or an array of items that we want to add.
      Both methods act in the same way, so let's discuss <em>prepend</em>.
    </p>
    <p>
      In this demo we have 20 items on start and 5 of them (95-99) are invisible on the backward direction.
      By pushing "Prepend" button we are going to add 4 (which is out input value) new items
      to the top of the list. After they are prepended, they may become visible when scrolling up.
      The <em>uiScroll</em> accurately injects prepended items into it's internal dataset, so
      1-4 new items replace old items with indexes 91-94.
    </p>
    <p>
      But if we scroll away and make '90s items invisible and deleted from the viewport,
      and then scroll back, we will realise that nothing changes: 91-94 items have their rightful place.
      This is how the <em>Datasource</em> implemented, it does not take into account our dataset changes.
      Next sample provides one of the approach of consistent <em>Datasource</em> implementation with
      <em>Adapter.append</em> and <em>Adapter.prepend</em> methods usage.
    </p>
  </div>
</app-demo>
